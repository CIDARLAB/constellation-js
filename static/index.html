<html>
<head>
  <script src="http://imparse.org/js/lib/imparse.js"></script>
  <script src="http://wzrd.in/standalone/uuid%2Fv4@latest"></script>            
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gojs/1.8.2/go-debug.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

</head>

  <body>

    <h3>Ibis</h3>

    <!-- <input id="langInput" type="text" style="height: 200px; width: 100%"> <br> -->
    <textarea id="langInput" style="height: 200px; width:100%" name="paragraph_text" cols="50" rows="10"></textarea>

    <input id="submitBtn" type="button" value="Submit">
    <br><br>
    <div id="stateGraph" style="border: solid 1px black; width: 100%; height: 400px"></div>



<script>


const GRAMMER_DEF = [{"Seq":[{"Then":[["Exp"],"then",["Seq"]]},{"":[["Exp"]]}]},{"Exp":[{"Or":[["Term"],"or",["Exp"]]},{"And":[["Term"],"and",["Exp"]]},{"":[["Term"]]}]},{"Term":[{"OneOrMore":["one-or-more",["Term"]]},{"ZeroOrMore":["zero-or-more",["Term"]]},{"":["(",["Seq"],")"]},{"Atom":[{"RegExp":"([A-Za-z0-9]|-|_)+"}]}]}]

const EPSILON = "o";
const ATOM = "atom";
const ACCEPT = "accept";

$(document).ready(function() {
  $("#submitBtn").click(function(){
  
    var langText = $('#langInput').val();
    var parsed = imparse.parse(GRAMMER_DEF, langText);

    parseAndDisplay(parsed);
  });
});
  
function initializeStateGraph() {
  var g = go.GraphObject.make;
  var myDiagram = g(go.Diagram, 'stateGraph', {
    initialContentAlignment: go.Spot.Center
  });

  return myDiagram;
}
      
function parseAndDisplay(parsed) {

  var myDiagram = initializeStateGraph();

  var stateGraph = {"nodes": [], "edges": []}  
  var nodeStack = {"roots": [], "leaves": []};

  populateGraph(parsed, stateGraph, nodeStack);
  addAcceptNodes(stateGraph, nodeStack);

  myDiagram.model = new go.GraphLinksModel(stateGraph.nodes, stateGraph.edges);
}

function addAcceptNodes(stateGraph, nodeStack) {
  var len = nodeStack.leaves.length;
  for (var i = 0; i < len; i++) {
    var n = nodeStack.leaves.pop();
    var id = uuidv4();
    stateGraph.nodes.push({key: id, text: ACCEPT});
    stateGraph.edges.push({from: n.key, to: id});
  }
}

function populateGraph(parsed, stateGraph, nodeStack) {

  if (parsed.Atom) {
    var nodeId = uuidv4();
    var node = {key: nodeId, text: parsed.Atom, dataType: ATOM}
    nodeStack.leaves.push(node);
    stateGraph.nodes.push(node);

    return;
  }

  if (Array.isArray(parsed)) {

    // var parentId = uuidv4();
    for (var i = 0; i < parsed.length; i++) {
      populateGraph(parsed[i], stateGraph, nodeStack);
    }
    return;
  }

  if (Object.keys(parsed).length > 0) {

    for (k in parsed) {
      var operation = k;
      populateGraph(parsed[k], stateGraph, nodeStack)
      handleOp(operation, nodeStack, stateGraph);
    }
  }
}



function handleOp(op, nodeStack, stateGraph) {
  var parentId = uuidv4();
  var parentNode = {key: parentId, text: EPSILON, dataType: EPSILON};
  stateGraph.nodes.push(parentNode);

  if (op === "Or") {
    var a = '';
    if (nodeStack.roots.length > 0) {
      console.log('root')
      a = nodeStack.roots.pop();

    } else {
      console.log('leaves')
      a = nodeStack.leaves.pop();
    }

    var b = nodeStack.leaves.pop();

    stateGraph.edges.push({from: parentId, to: a.key, text: op});
    stateGraph.edges.push({from: parentId, to: b.key, text: op});
    console.log(a.dataType, b.dataType);
    if (a.dataType === ATOM) {
      nodeStack.leaves.push(a);
    } 
    if (b.dataType === ATOM) {
      nodeStack.leaves.push(b);
    }

    
    nodeStack.roots.push(parentNode);
  }

  if (op === "Then") {
    console.log(nodeStack.leaves.length)
    var b = nodeStack.leaves.pop();
    

    // if (nodeStack.leaves.length == 0) {
    //   var a = nodeStack.roots.pop();
    //   stateGraph.edges.push({from: parentId, to: a.key, text: op});      
    //   stateGraph.edges.push({from: a.key, to: b.key, text: op});

    // } else {
      stateGraph.edges.push({from: parentId, to: b.key, text: op});
      var len = nodeStack.leaves.length; 
      var prevNode = null;
      for (var i = 0; i < len; i++) {
        prevNode = nodeStack.leaves.pop();
              
        stateGraph.edges.push({from: prevNode.key, to: parentId, text: op});
      }
    // }
    nodeStack.leaves.push(b);

    if (nodeStack.roots.length === 0) {
      nodeStack.roots.push(prevNode);
    }
  }

  if (op === "ZeroOrMore") {
    // var a = nodeStack.roots.pop();
    parentNode.text = ACCEPT;
    parentNode.dataType = ACCEPT;

    // If existing root
    if (nodeStack.roots.length === 1) {
      var root = nodeStack.roots.pop();
      stateGraph.edges.push({from: parentId, to: root.key});

      for (var i = 0; i < nodeStack.leaves.length; i++) {
        var leaf = nodeStack.leaves[i].key;
        stateGraph.edges.push({from: leaf, to: parentId, text: op});
        // stateGraph.edges.push({from: parentId, to: l})      

      }
    // No root yet
    } else {
      var leaf = nodeStack.leaves.pop();
      stateGraph.edges.push({from: parentId, to: leaf.key, text: op});
      stateGraph.edges.push({from: leaf.key, to: parentId, text: op});
    }
    nodeStack.roots.push(parentNode);
    // nodeStack.leaves.push(a);
  }

  // if (op === "OneOrMore") {
  //   // edge pointing to itself should be on leaf... not parent
  //   var a = nodeStack.roots.pop();
  //   stateGraph.edges.push({from: a, to: a});
  //   stateGraph.edges.push({from: parentId, to: a})

  //   nodeStack.roots.push(parentId);
  //   nodeStack.leaves.push(a);
  // }
}

// function collapseEpsilons() {
  // dfs (post-order)
  // if (child node is epsilon and parent node is epsilon)
  // delete child node
  // transfer child node's edges to parent node
// }

</script>
</body>

</html>